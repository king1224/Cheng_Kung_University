開發平台(Development Platform):	win10

使用開發環境(Development environment): DEV-C++ 5.8.3

程式功能(Program Functions): 輸入一些節點，依序照level order tree的方式儲存，
			　　 然後作刪除節點的動作，依序照level order tree的方式印出。


程式設計(Program design):　　先將所有輸入的節點先存在a陣列，再依序擺好到tree陣列媕Y，
			　　 再將所有要刪除的節點存在a陣列，再依序從tree裡一個一個刪除。


in main：
20-50行的 do+for迴圈：將連續輸入的多個數字視為一個數字儲存(例如：原先輸入123會存在3格中，轉換為一百二十三存在第一格)
52-59行的 do迴圈：從剛剛儲存的節點中，用函式check，依序以level order的方式一個一個存進tree陣列，
		　count計算共有多少個節點。
64-94行的 do+for迴圈：與剛剛18-48行的一樣，第60行做變數初始化的動作。
97-103行的 do迴圈：從剛剛儲存要刪除的節點中，用函式dele，依序從tree中刪除。
107-114的 while迴圈：有count個節點數，印到count==0為止，如果tree中==-10(這個位置無節點)則印X，有節點則印節點數字。

in check：將節點插入tree
把a放入tree，與第pos的節點做比較，若a較大則往右子樹，反之則往左子樹，當走到的pos等於初始值(-10)，則將a放在這格。

in find：找出這個值的節點在哪
共有count個節點，故最多找count次，num大於現在節點則往右子樹，反之往左子樹，若無誰大誰小即找到節點位置了。

in dele：刪除節點
如果要刪除的節點左子樹為空，右子樹整棵移上來，反之亦然，若左右子樹皆為空，直接刪除，
若左右子樹皆非空，先取左子樹中最大的數字，來當刪除的節點值，再與子樹比大小，若不符合level order即對調位置，再往下比

in move：用來移動一整棵樹(包含X也要移動)，此move是一層一層移動。
pos為這棵樹的root，樹的下一層要移動的數量都是當前層的兩倍，經過觀察發現要移動時減掉的pos，下一層也是當前層的兩倍
(例如a[1],a[3],a[4]的a[0]拿掉了，a[1]->a[0]是pos-1，a[3]->a[1]與a[4]->a[2]是pos-2*1)
而後再呼叫自己move的pos紀錄某一層的起始位置，橫向移動num個節點。
